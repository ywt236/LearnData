#### 编译原理

##### 第一章    引论

###### 执行高级语言程序的步骤

* 用编译程序把高级语言翻译成为机器语言程序
* 运行机器语言程序，求得计算结果

###### 翻译程序

* 一个程序，能把源语言程序转化为目标语言程序，而且两者之间在逻辑上是等价的

###### 编译程序

* 一个翻译程序，源语言是高级语言如C Java，目标语言是低级语言如汇编，机器语言，则此程序称为编译程序

###### 解释程序

* 不产生目标代码，而是边解释边执行源程序的程序

###### 编译程序的分类

* 诊断编译程序    专门用于程序的开发与调试的编译程序
* 优化编译程序    着重于提高目标代码效率的编译程序
* 交叉编译程序    产生不同于宿主机的机器代码
* 可变目标编译程序    不需重写编译程序中与机器无关部分，就能改变目标机

###### 编译过程

* 词法分析    
  * 识别源程序中的单词符号，通常使用正规式和有限自动机
* 语法分析    
  * 判断更大的语法范畴（表达式）进行，通常使用上下文无关文法
* 语义分析及中间代码的产生   
  * 对各语法范畴，分析其含义，并进行初步翻译，通常使用属性文法描述语义规则
  * 包括静态语义检查，以及中间代码的翻译
  * 中间代码包括有 四元式，三元式，间接三元式，逆波兰记号，树形表示
* 优化    
  * 对中间代码进行加工
  * 原则是程序的等价变换规则
* 目标代码的生成
  * 将中间代码变换为特定机器上的低级语言代码
  * 目标代码的形式有 绝对指令代码  可重定位的指令代码  汇编指令代码

###### 编译程序的结构

* 编译程序总框
  * 词法分析器 
  * 语法分析器
  * 语义分析及中间代码产生器
  * 优化器
  * 目标代码生成器
  * 表格与表格管理
    * 符号表，用于登记源程序中出现的每个名字及各种属性
  * 出错处理
    * 对源程序中的错误进行处理
    * 错误通常分为语法错误与语义错误
* 遍    对源程序或者中间结果从头到尾扫描一次，并做有关的加工处理
* 可以将几个阶段合为一遍，也可以一个阶段分为若干遍
* 编译前端：与目标机无关的部分，包括词法分析，语法分析，语义分析及中间代码的产生    
* 编译后端：与目标机有关的部分，包括优化，目标代码的生成

###### 程序的设计环境

* 集成化的程序设计环境
  * 编辑程序
  * 链接程序
  * 编译程序
  * 调试程序等等

###### 编译程序的生成

* 移植方法         
* 自编译方法    先对语言的核心部分进行编译器的编写，再以它为工具构造较大的编译程序

###### 自动产生编译程序的工具

* 词法分析器的自动产生    LEX
* 语法分析器的自动产生    YACC



##### 第二章    高级语言及其语法描述

###### 程序语言的定义

* 一定字母表上的一字符串

* 一个程序语言为一个记号系统，主要由语法及语义两方面定义
* 有时也包括语用信息

###### 语法

* 一组规则，用于产生合式的程序

* 包括词法规则：定义了字母表中那样的字符串为单词符号
* 包括语法规则：定义了语法单位的形成规则（表达式，语句，分程序，函数等）

###### 语义

* 一组规则，定义了一个程序的含义
* 基于属性文法的语法制导翻译

###### 程序的基本功能

* 描述数据以及对数据进行运算
* 程序的层次结构：程序-》子程序-》语句-》表达式-》单词符号
* 可自上而下，或自下而上理解程序
* 程序每个组成部分都有逻辑和实现两方面的意义

###### 高级语言的分类

* 强制式语言（过程式语言）
  * 命令驱动，面向语句
* 应用式语言（函数式语言）
  * 从已有的函数出发，构造更复杂的函数
* 基于规则式语言
  * 检查一定条件，符合则执行
* 面向对象语言
  * 特征：封装性，继承性，多态性

###### 数据类型的三要素

* 区别这种数据类型的属性
* 可以具有的值
* 作用于此数据类型的操作

###### 初等数据类型

* 数值数据：整数，浮点数
* 逻辑数据：布尔型数据
* 字符数据：字符型或字符串型
* 指针类型：指向另一些数据

标识符为字母或数字，字母开头组成的一个字符串

###### 名字

* 由值和属性组成
* 属性由类型与作用域
* 静态：名字属性通过说明定义    动态：名字属性执行时才确定

###### 数据结构

* 数组
* 记录
* 栈
* 队列
* 抽象数据类型：包括数据对象，作用于对象的一组操作，对此类型对象的封装

###### 表达式

* 由运算符和算符组成
* 表达式的形成规则    P23
* 优先顺序 p23

###### 语句

* 赋值句
* 控制语句
* 说明句
* 简单句和复合句

###### 程序语言的语法描述

* 概念介绍
  * ∑是有穷字母表，它的每个元素为一个符号，符号串为∑上的有穷序列
  * 不含任何符号的字符串为ε，∑*表示全体字符串的集合，包括空字
  * φ为空集
  * UV = {αβ|α∈U && β∈V}    连接积
  * Vⁿ  为n个V的连接集
  * V* 为 Vº∪V¹ ...    （闭包），V的有限次连接组成
  * V+ 为正则闭包
* 上下文无关文法
  * 文法是描述语法的形式规则
  * 上下文无关文法是指，这样一种文法，它所定义的语法范畴是独立于环境的
  * 组成部分
    * 开始符号S
    * 一组终结符号，小写字母，单词符号或不可再分的基本符号
    * 一组非终结符号，大写字母，代表语法范畴
    * 一组产生式，A->B，
  * 上下文无关文法的四元式：G=（Vt，Vn，S，φ）
  * 候选式：一个产生式右部分割的部分
  * ->读为定义为，| 读为或，=>直接推出，-+>一步或多步推导出，-*>0步或多步推导出
  * 句型：由开始符号推导出的α 
  * 句子：句型中只含有终结符
  * 语言：所有句子的集合，L(G)
  * 最左推导：每次选择句型最左非终结符进行替换
  * 最右推导：每次选择句型最右非终结符进行替换
* 语法分析树与二义性
  * 用一张图来表示一个句型的推导，称为语法分析树
  * 根结由开始符号出发，非终结符被候选式替换
  * 一个句型对应两颗语法分析树，则称该文法是二义的
  * 不同文法定义的语言可能是相同的

###### 形式语言鸟瞰

* 0型文法，短语文法
  * 条件 α中包含非终结符
* 1型文法，上下文有关文法
  * |β|>|α|    ,S->ε例外，S不出现在右部
* 2型文法，上下文无关文法
  * α为非终结符
* 3型文法，（右线性文法，左线性文法）
  * A->aB 或 A->a

##### 第三章    词法分析

###### 任务

* 从左至右逐个字符地对源程序进行扫描，产生一个个单词符号

###### 单词符号的分类

* 关键字
* 标识符
* 常数
* 运算符
* 界符

###### 单词符号的表示（二元式）

* （单词种别，单词符号的属性值）

词法分析器可以作为一个独立的一遍，也可以为语法分析的子程序

###### 词法分析器的设计

* 输入，预处理
  * 输入串一般放进输入缓冲区
  * 把输入串预处理一下，剔除不必要的成分
  * 将一串确定长度的输入字符串放入，两个扫描缓冲区，使用起点指示器和搜索指示器
* 单词符号的识别，超前搜索

###### 状态转换图

* 转换图是一张有限方向图，结点用圆圈表示，一个初态，至少一个终态（双圈表示）
* *表示多读了一位，应退还
* 不使用超前搜索的条件
  * 保留字不做标识符
  * 各个单词符号之间有空格

###### 正规式与正规集

* 正规式用于表示正规集
* a|b(正规式) => {a,b}(正规集)
* 有 连接·  或| 闭包*
* 正规式的关系

###### 确定有限自动机（DFA）

* 一个确定有限自动机是一个五元式
* M = (S,∑,δ,s0,F)
* S表示状态集，∑表示字母集，δ代表状态函数，s0为开始状态，F为终态集（可空）
* 状态转换矩阵    p48、
* 一个DFA表示一张状态转换图
* 从初态结点到终态结点，所有弧的标记符连接成的字α，称为可被M识别
* 所有被DFA识别的字记为L(M)

###### 非确定有限自动机（NFA）

* 与DFA区别
  * 初态集
  * 状态函数不同

###### NFA转DFA（子集法） 

* P48

###### 正规文法与有限自动机的等价性

- 对于正规文法G，和有限自动机M，若L(G)=L(M),则G和M为等价的
- 右线性正规文法 转 有限自动机
  - 非终结符号集变为状态集
  - 终结符号集变为字母集
  - 开始符号变为初态
  - 新增的终态为终态集
  - 产生式与状态映射符合的规则
    - A->a        F(A,a) = f
    - A->aB     F(A,a) = B
- 有限自动机 转 右线性正规文法
  - 状态集变为非终结符号集
  - 字母集变为终结符号集
  - 初态变为开始符号
  - 状态映射转变为产生式
    - 若F(A,a) = B ,B为终态，则 A->aB | a（注意）
    - 若F(A,a) = B,B不为终态，则 A->aB
- 左线性正规文法 转 自动有限机
  - 开始符号转为终态
  - 非终结符号集转为状态集
  - 终结符号集转为字母集
  - 新增初态
  - 产生式 转 状态映射变换
    - A->Ba    F(B,a) = A
    - A->a    F(q0,a) = A
- 自动有限机 转 左线性正规文法
  - 删除q0
  - 终态转变为开始符号
  - 状态集变为产生式
    - F(A,a) = B    若A为初态，则 B->a     
    - F(A,a) = B    若A不为初态，则B->Aa
  - 终态变为开始符号

###### 正规式转有限自动机

-  对于任何有限自动机，都存在一个正规式，使得L(M) = L(r)
- 有限自动机 转 正规式
  - 新增X初态  Y终态  ，X用空字连接所有初态，所有终态用空字连接Y
  - 使用三条规律化简有限自动机，直到只剩下X和Y，弧上表达式即为正规式
- 正规式 转 有限自动机
  - 对于单个 p54
  - 对于组合 p55    连续使用即可得到NFA

###### 确定有限自动机的化简

- 寻找一个状态数比M少的M‘，使得L(M)=L(M')
- 状态的等价与可区别的 ：若从状态s出发，读出w而停于终态；若从状态t出发，读出w而停于终态，则称s与t是等价的，否则为可区别的
- 一个DFA的最小化过程，旨在将M的状态集分割成一些不相交的子集，使任意两个子集之间的状态都是可区别的，同子集的状态之间都是等价的，这时即可消去其他等价状态
- 确定有限自动机的化简过程
  - 终态集与非终态集划分为两个子集
  - 根据每个子集中元素的Ia，Ib 进一步划分，若都属于一个子集，则不划分，否则划分
  - 含原来的初态的为新初态，含原来终态的为新终态

###### 词法分析器的自动产生

LEX程序

- 一组正规式
- 每个正规式的动作，用于指定识别后的动作

LEX源程序->(LEX编译程序)->词法分析器L

输入串->(词法分析器L)->单词符号

LEX编译程序旨在将一个LEX程序改造为一个词法分析器L，这个词法分析器将像有限自动机一样工作



##### 第四章    语法分析----自上而下分析

* 高级语言的语法结构适合用上下文无关文法分析
* 任务：分析并判断程序的语法结构是否符合语法规则
* 语法分析分为两类：自上而下分析，自下而上分析
* 自上而下分析的主旨是自上而下为输入串建立一颗语法树

###### 带回溯的自上而下分析

* 缺点
  * 若文法中含有左递归，则会陷入死循环
  * 回溯会浪费时间
  * 不知道输入串的错误位置
  * 效率低下

###### 不带回溯的自上而下分析（LL（1）分析法）

* LL(1)文法
  * 无左递归
  * 每一个非终结符的候选首符集相交为空
  * 每一个非终结符的FIRST集与FOLLOW集相交为空
* 消除左递归
  * 直接左递归
    * 文法中形如 P -> Pa|Pb|c|d,改为 P->cP'|dP';  P'->aP'|bP'|@;
    * 直接左递归变直接右递归
  * 间接左递归
    * P70
* 每一个非终结符的候选首符集相交为空
  * 提取公共左因子 P71
* 求终结符或者非终结符的FIRST集合
  * P78
* 求α的FIRST集合
  * P79
* 求FOLLOW集合
  * P79
* 递归下降分析程序构造
  * 用递归的方法实现LL（1）分析
  * 构造方法
    * main函数中调用开始符号过程E（）
    * 过程名字为产生式左部的非终结符
    * 过程体按产生式右部符号顺序调用
    * 每匹配一个终结符，读入下一字符
* 预测分析程序
  * 使用一张表和栈来实现LL（1）分析
  * 步骤
    * 初始化，输入串末尾添加#，向符号栈中推入#E
    * 若X = a = # ，则分析成功
    * 若X = a !=# ,   则将栈pop，a指向下一位
    * 若X为非终结符   ，则将栈pop，同时将M[A,a] 逆序输入
  * 预测分析步骤
    * 步骤    符号栈    输入串    所用产生式
  * 预测分析表的构造
    * 对每一个产生式A->α执行第2步，第3步
    * 若a属于FIRST(α),则把A->α置入M[A,a]中
    * 若@属于FIRST(α)，且b属于FOLLOW（A），把M[A,b]置入A->α
    * 所有无定义的地方为产生错误的地方
  * 错误分析
    * 栈顶终结符与当前输入符号不匹配
    * A为栈顶元素，a为输入符号，但M[A,a]为空
    * 从错误中恢复的做法    p80



