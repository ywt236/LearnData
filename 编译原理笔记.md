#### 编译原理

##### 第一章    引论

###### 执行高级语言程序的步骤

* 用编译程序把高级语言翻译成为机器语言程序
* 运行机器语言程序，求得计算结果

###### 翻译程序

* 一个程序，能把源语言程序转化为目标语言程序，而且两者之间在逻辑上是等价的

###### 编译程序

* 一个翻译程序，源语言是高级语言如C Java，目标语言是低级语言如汇编，机器语言，则此程序称为编译程序

###### 解释程序

* 不产生目标代码，而是边解释边执行源程序的程序

###### 编译程序的分类

* 诊断编译程序    专门用于程序的开发与调试的编译程序
* 优化编译程序    着重于提高目标代码效率的编译程序
* 交叉编译程序    产生不同于宿主机的机器代码
* 可变目标编译程序    不需重写编译程序中与机器无关部分，就能改变目标机

###### 编译过程

* 词法分析    
  * 识别源程序中的单词符号，通常使用正规式和有限自动机
* 语法分析    
  * 判断更大的语法范畴（表达式）进行，通常使用上下文无关文法
* 语义分析及中间代码的产生   
  * 对各语法范畴，分析其含义，并进行初步翻译，通常使用属性文法描述语义规则
  * 包括静态语义检查，以及中间代码的翻译
  * 中间代码包括有 四元式，三元式，间接三元式，逆波兰记号，树形表示
* 优化    
  * 对中间代码进行加工
  * 原则是程序的等价变换规则
* 目标代码的生成
  * 将中间代码变换为特定机器上的低级语言代码
  * 目标代码的形式有 绝对指令代码  可重定位的指令代码  汇编指令代码

###### 编译程序的结构

* 编译程序总框
  * 词法分析器 
  * 语法分析器
  * 语义分析及中间代码产生器
  * 优化器
  * 目标代码生成器
  * 表格与表格管理
    * 符号表，用于登记源程序中出现的每个名字及各种属性
  * 出错处理
    * 对源程序中的错误进行处理
    * 错误通常分为语法错误与语义错误
* 遍    对源程序或者中间结果从头到尾扫描一次，并做有关的加工处理
* 可以将几个阶段合为一遍，也可以一个阶段分为若干遍
* 编译前端：与目标机无关的部分，包括词法分析，语法分析，语义分析及中间代码的产生    
* 编译后端：与目标机有关的部分，包括优化，目标代码的生成

###### 程序的设计环境

* 集成化的程序设计环境
  * 编辑程序
  * 链接程序
  * 编译程序
  * 调试程序等等

###### 编译程序的生成

* 移植方法         
* 自编译方法    先对语言的核心部分进行编译器的编写，再以它为工具构造较大的编译程序

###### 自动产生编译程序的工具

* 词法分析器的自动产生    LEX
* 语法分析器的自动产生    YACC



##### 第二章    高级语言及其语法描述

###### 程序语言的定义

* 一定字母表上的一字符串

* 一个程序语言为一个记号系统，主要由语法及语义两方面定义
* 有时也包括语用信息

###### 语法

* 一组规则，用于产生合式的程序

* 包括词法规则：定义了字母表中那样的字符串为单词符号
* 包括语法规则：定义了语法单位的形成规则（表达式，语句，分程序，函数等）

###### 语义

* 一组规则，定义了一个程序的含义
* 基于属性文法的语法制导翻译

###### 程序的基本功能

* 描述数据以及对数据进行运算
* 程序的层次结构：程序-》子程序-》语句-》表达式-》单词符号
* 可自上而下，或自下而上理解程序
* 程序每个组成部分都有逻辑和实现两方面的意义

###### 高级语言的分类

* 强制式语言（过程式语言）
  * 命令驱动，面向语句
* 应用式语言（函数式语言）
  * 从已有的函数出发，构造更复杂的函数
* 基于规则式语言
  * 检查一定条件，符合则执行
* 面向对象语言
  * 特征：封装性，继承性，多态性

###### 数据类型的三要素

* 区别这种数据类型的属性
* 可以具有的值
* 作用于此数据类型的操作

###### 初等数据类型

* 数值数据：整数，浮点数
* 逻辑数据：布尔型数据
* 字符数据：字符型或字符串型
* 指针类型：指向另一些数据

标识符为字母或数字，字母开头组成的一个字符串

###### 名字

* 由值和属性组成
* 属性由类型与作用域
* 静态：名字属性通过说明定义    动态：名字属性执行时才确定

###### 数据结构

* 数组
* 记录
* 栈
* 队列
* 抽象数据类型：包括数据对象，作用于对象的一组操作，对此类型对象的封装

###### 表达式

* 由运算符和算符组成
* 表达式的形成规则    P23
* 优先顺序 p23

###### 语句

* 赋值句
* 控制语句
* 说明句
* 简单句和复合句

###### 程序语言的语法描述

* 概念介绍
  * ∑是有穷字母表，它的每个元素为一个符号，符号串为∑上的有穷序列
  * 不含任何符号的字符串为ε，∑*表示全体字符串的集合，包括空字
  * φ为空集
  * UV = {αβ|α∈U && β∈V}    连接积
  * Vⁿ  为n个V的连接集
  * V* 为 Vº∪V¹ ...    （闭包），V的有限次连接组成
  * V+ 为正则闭包
* 上下文无关文法
  * 文法是描述语法的形式规则
  * 上下文无关文法是指，这样一种文法，它所定义的语法范畴是独立于环境的
  * 组成部分
    * 开始符号S
    * 一组终结符号，小写字母，单词符号或不可再分的基本符号
    * 一组非终结符号，大写字母，代表语法范畴
    * 一组产生式，A->B，
  * 上下文无关文法的四元式：G=（Vt，Vn，S，φ）
  * 候选式：一个产生式右部分割的部分
  * ->读为定义为，| 读为或，=>直接推出，-+>一步或多步推导出，-*>0步或多步推导出
  * 句型：由开始符号推导出的α 
  * 句子：句型中只含有终结符
  * 语言：所有句子的集合，L(G)
  * 最左推导：每次选择句型最左非终结符进行替换
  * 最右推导：每次选择句型最右非终结符进行替换
* 语法分析树与二义性
  * 用一张图来表示一个句型的推导，称为语法分析树
  * 根结由开始符号出发，非终结符被候选式替换
  * 一个句型对应两颗语法分析树，则称该文法是二义的
  * 不同文法定义的语言可能是相同的

###### 形式语言鸟瞰

* 0型文法，短语文法
  * 条件 α中包含非终结符
* 1型文法，上下文有关文法
  * |β|>|α|    ,S->ε例外，S不出现在右部
* 2型文法，上下文无关文法
  * α为非终结符
* 3型文法，（右线性文法，左线性文法）
  * A->aB 或 A->a

##### 第三章    词法分析

###### 任务

* 从左至右逐个字符地对源程序进行扫描，产生一个个单词符号

###### 单词符号的分类

* 关键字
* 标识符
* 常数
* 运算符
* 界符

###### 单词符号的表示（二元式）

* （单词种别，单词符号的属性值）

词法分析器可以作为一个独立的一遍，也可以为语法分析的子程序

###### 词法分析器的设计

* 输入，预处理
  * 输入串一般放进输入缓冲区
  * 把输入串预处理一下，剔除不必要的成分
  * 将一串确定长度的输入字符串放入，两个扫描缓冲区，使用起点指示器和搜索指示器
* 单词符号的识别，超前搜索

###### 状态转换图

* 转换图是一张有限方向图，结点用圆圈表示，一个初态，至少一个终态（双圈表示）
* *表示多读了一位，应退还
* 不使用超前搜索的条件
  * 保留字不做标识符
  * 各个单词符号之间有空格

###### 正规式与正规集

* 正规式用于表示正规集
* a|b(正规式) => {a,b}(正规集)
* 有 连接·  或| 闭包*
* 正规式的关系

###### 确定有限自动机（DFA）

* 一个确定有限自动机是一个五元式
* M = (S,∑,δ,s0,F)
* S表示状态集，∑表示字母集，δ代表状态函数，s0为开始状态，F为终态集（可空）
* 状态转换矩阵    p48、
* 一个DFA表示一张状态转换图
* 从初态结点到终态结点，所有弧的标记符连接成的字α，称为可被M识别
* 所有被DFA识别的字记为L(M)

###### 非确定有限自动机（NFA）

* 与DFA区别
  * 初态集
  * 状态函数不同

###### NFA转DFA（子集法） 

* P48

###### 正规文法与有限自动机的等价性

* P54

###### 确定有限自动机的化简

* 寻找一个状态数比M少的DFA M‘ ，使得L(M)=L(M')
* M的两个状态是等价的    P56
* 状态划分法P57



##### 第四章    语法分析-----自上而下分析

* 语法分析器的功能：分析并判断程序的语法结构是否符合语法规则
* 语法分析从构造语法分析树来讲分为：自上而下分析法，自下而上分析法
* 自上而下就是从文法的开始符号出发，向下推导，推出句子，分为带回溯，以及不带回溯两种方法
* 自上而下分析的目的是为了从开始符号出发，自上而下地为输入串建立一颗语法树

###### 带回溯的自上而下分析

* P67
* 缺点
  * 遇见左递归文法，则会陷入死循环
  * 由于回溯，浪费时间
  * 分析不成功时，不知道报错位置

###### 不带回溯的自上而下分析（LL(1)分析法）

* LL(1)文法
  * 无左递归
  * 各候选式的FIRST集合不相交
  * 若候选式中的FIRST集包含@，则FIRST（A）与FALLOW（A）不相交
* 消除左递归
  * 消除直接左递归    P69
  * 消除间接左递归  （一个文法不含回路，以及右部不为@）  P69
* 消除候选首符集的相交（提取公共左因子）
  * P71

###### FIRST集的构造

* FIRST集的含义：P71

* FIRST集的求法：P78

###### FALLOW集的构造

* FOLLOW集的定义：P73
* FOLLOW集的求法：P79

###### LL（1）文法分析

* P73

###### 递归下降分析实现LL(1)分析

* 规则P75
* 扩充的巴科斯范式p75

###### 预测分析分析实现LL（1）分析

* 一张预测分析表，一个输入串，一个符号栈
* 分析规则    P77
* 预测分析表的构造    P78
* 一个文法的预测分析表不含多重定义入口，当且仅当文法为LL（1）文法

###### LL（1）分析中的错误处理

* 错误情况
  * 栈顶终结符与输入串的符号不匹配
  * 分析表中该项为空
* 错误处理
  * 发现错误后，要尽快从错误中恢复过来，基本做法就是跳过输入串的一些符号，直至遇到“同步符号”为至
* 同步符号集的选择
* 处理方法    P80

###### 